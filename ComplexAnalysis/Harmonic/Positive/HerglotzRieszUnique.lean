 /-
Copyright (c) 2025 [Your Name]. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: [Your Name], [Collaborator Name if applicable]
-/
module
public import Mathlib.Analysis.Complex.Harmonic.Analytic
public import Mathlib.Analysis.Normed.Group.FunctionSeries
public import Mathlib.MeasureTheory.Measure.HasOuterApproxClosed
public import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
public import Mathlib.Topology.ContinuousMap.StoneWeierstrass
public import Mathlib.Tactic

/-!
# Uniqueness of the Herglotzâ€“Riesz measure

## Main Results

Theorem `HerglotzRiesz_representation_uniqueness`:

If for two probability measures `Î¼â‚` and `Î¼â‚‚` on the unit circle
the two functions âˆ« x, (x + z) / (x - z) âˆ‚Î¼â‚ and âˆ« x, (x + z) / (x - z) âˆ‚Î¼â‚‚ are
identical on the unit disc, then `Î¼â‚` = `Î¼â‚‚`.
-/

public section
set_option Elab.async false
open MeasureTheory Metric Complex Topology
--#count_heartbeats in 4500
/-- Equal moments with natural exponents imply equal moments with integer exponents. -/
lemma moments_eq_integers (Î¼â‚ Î¼â‚‚ : ProbabilityMeasure (sphere (0 : â„‚) 1))
    (h : âˆ€ n : â„•, âˆ« x : sphere (0 : â„‚) 1, x.val ^ n âˆ‚Î¼â‚ = âˆ« x : sphere (0 : â„‚) 1, x.val ^ n âˆ‚Î¼â‚‚) :
    âˆ€ n : â„¤, âˆ« x : sphere (0 : â„‚) 1, x.val ^ n âˆ‚Î¼â‚ = âˆ« x : sphere (0 : â„‚) 1, x.val ^ n âˆ‚Î¼â‚‚ := by
  -- For n < 0, let m = -n > 0. Then z^n = z^{-m} = (z^m)^{-1}.
  intro n
  by_cases h_neg : n < 0
  Â· obtain âŸ¨m, rflâŸ© : âˆƒ m : â„•, n = -m := by
      exact âŸ¨Int.toNat (-n), by rw [Int.toNat_of_nonneg (neg_nonneg.mpr h_neg.le)]; ringâŸ©
    -- Since |z|=1 for `z` in the unit circle, we have z^{-m} = conj{z^m}.
    have h_inv : âˆ€ x : sphere (0 : â„‚) 1, x ^ (-m : â„¤) = starRingEnd â„‚ (x ^ m) := by
      simp only [mem_sphere_zero_iff_norm, Subtype.forall]
      intro x hx
      rw [zpow_neg]
      rw [inv_eq_of_mul_eq_one_right]
      simp [â† mul_pow, mul_conj, normSq_eq_norm_sq, hx]
    /- Since |z|=1 for `z` in the unit circle, we have âˆ« z^{-m} dÎ¼â±¼ = âˆ« conj{z^m} dÎ¼â±¼, j=1,2. -/
    have h_inv_integral : âˆ« x : sphere (0 : â„‚) 1, (x : â„‚) ^ (-m : â„¤) âˆ‚Î¼â‚ =
      starRingEnd â„‚ (âˆ« x : sphere (0 : â„‚) 1, (x : â„‚) ^ m âˆ‚Î¼â‚) âˆ§ âˆ« x : sphere (0 : â„‚) 1,
        (x : â„‚) ^ (-m : â„¤) âˆ‚Î¼â‚‚ = starRingEnd â„‚ (âˆ« x : sphere (0 : â„‚) 1, (x : â„‚) ^ m âˆ‚Î¼â‚‚) := by
      simp only [h_inv, integral_conj]; simp
    rw [h_inv_integral.1, h_inv_integral.2, h]
  Â· have hn : 0 â‰¤ n := by omega
    lift n to â„• using hn
    simp only [zpow_natCast]
    exact h n

--#count_heartbeats in
lemma continuous_zpow_on_unit_circle (n : â„¤) :
    Continuous (fun x : sphere (0 : â„‚) 1 => x.val ^ n) := by
  cases n with
  | ofNat m =>
      convert continuous_subtype_val.pow (n := m) using 1
      infer_instance
  | negSucc m =>
       simp only [zpow_negSucc]
       apply Continuous.invâ‚€
       Â· convert continuous_subtype_val.pow (n := m+1) using 1
         infer_instance
       Â· intro x
         apply pow_ne_zero _
         have : â€–(x : â„‚)â€– = 1 := mem_sphere_zero_iff_norm.mp x.2
         rw [â† norm_ne_zero_iff, this]
         exact one_ne_zero

--#count_heartbeats in --109296  TODO
/-- The span of moments is dense in the space of continuous functions on the unit circle. -/
lemma span_moments_dense : (Submodule.span â„‚ (Set.range (fun n : â„¤ => ContinuousMap.mk (
    fun x : sphere (0 : â„‚) 1 => x.val ^ n)
      (continuous_zpow_on_unit_circle n)))).topologicalClosure = âŠ¤ := by
  -- Let `A` be the *subalgebra of C(âˆ‚ğ”», â„‚) generated by {z : âˆ‚ğ”» â†¦ z},
  -- wich contains the span of {z â†¦ z^n | n âˆˆ â„¤}.
  set A : StarSubalgebra â„‚ (ContinuousMap (sphere (0 : â„‚) 1) â„‚) := StarAlgebra.adjoin â„‚
    {ContinuousMap.mk fun x : sphere (0 : â„‚) 1 => x.val}
  rw [eq_top_iff]
  /- By the Stone-Weierstrass theorem, since `A` is a subalgebra of
  C(âˆ‚ğ”», â„‚) that separates points and contains the constant functions,
  `A` is dense in C(âˆ‚ğ”», â„‚). -/
  have h_dense : Dense (A : Set (ContinuousMap (sphere (0 : â„‚) 1) â„‚)) := by
    have h_stone_weierstrass : âˆ€ (A : StarSubalgebra â„‚ (ContinuousMap (sphere (0 : â„‚) 1) â„‚)),
      (âˆ€ x y : sphere (0 : â„‚) 1, x â‰  y â†’ âˆƒ f âˆˆ A, f x â‰  f y) â†’
        (âˆ€ c : â„‚, ContinuousMap.const (sphere (0 : â„‚) 1) c âˆˆ A) â†’
          Dense (A : Set (ContinuousMap (sphere (0 : â„‚) 1) â„‚)) := by
      intro A hA hA'
      have := @ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints â„‚
        (sphere (0 : â„‚) 1)
      simp [SetLike.ext_iff] at this hA hA'
      convert this A _ using 2
      Â· intro x y hxy
        have hx_norm : â€–(x : â„‚)â€– = 1 := by exact mem_sphere_zero_iff_norm.mp x.2
        have hy_norm : â€–(y : â„‚)â€– = 1 := by exact mem_sphere_zero_iff_norm.mp y.2
        specialize hA x.1 hx_norm y.1 hy_norm
        obtain âŸ¨f, hf_mem, hf_neâŸ© := hA (Subtype.coe_ne_coe.mpr hxy)
        exact âŸ¨f, âŸ¨f, hf_mem, rflâŸ©, hf_neâŸ©
    apply h_stone_weierstrass A
    Â· rintro âŸ¨a, haâŸ© âŸ¨b, hbâŸ© hab
      use ContinuousMap.mk (fun x : sphere (0 : â„‚) 1 => x.val)
      refine âŸ¨?_, fun h => hab (Subtype.ext h)âŸ©
      exact Algebra.subset_adjoin (Set.mem_insert _ _)
    Â· intro c
      convert Subalgebra.algebraMap_mem _ c
  intro x hx
  refine closure_mono ?_ (h_dense x)
  -- We show that the span of the moments contains `A`.
  intro f hf
  induction hf using StarAlgebra.adjoin_induction with
  | mem x hx =>
      simp only [Set.mem_singleton_iff] at hx
      rw [hx]
      apply Submodule.subset_span
      use (1 : â„¤)
      ext
      simp only [zpow_one]
  | algebraMap r =>
    refine Submodule.mem_span.mpr ?_
    intro p hp
    have h1 : (1 : C((sphere (0 : â„‚) 1), â„‚)) âˆˆ p := hp âŸ¨0, by ext x; simpâŸ©
    have hsmul : r â€¢ (1 : C((sphere (0 : â„‚) 1), â„‚)) âˆˆ p := p.smul_mem r h1
    convert hsmul using 1
    simp [Algebra.smul_def]
  | add => exact AddMemClass.add_mem â€¹_â€º â€¹_â€º
  | mul =>
    rename_i hx hy
    simp only [SetLike.mem_coe] at hx hy âŠ¢
    rw [Submodule.mem_toAddSubmonoid] at hx hy âŠ¢
    rw [Finsupp.mem_span_range_iff_exists_finsupp] at hx hy
    obtain âŸ¨câ‚, hcâ‚âŸ© := hx; obtain âŸ¨câ‚‚, hcâ‚‚âŸ© := hy; rw [â† hcâ‚, â† hcâ‚‚]
    simp [Finsupp.sum, Finset.sum_mul _ _ _]
    simp only [Finset.mul_sum _ _ _]
    refine Submodule.sum_mem _ fun i hi =>
      Submodule.smul_mem _ _ (Submodule.sum_mem _ fun j hj => ?_)
    -- We use that the product of two Laurent polynomials is also a Laurent polynomial.
    -- have h_prod : (câ‚ i â€¢ ContinuousMap.mk (fun x : sphere (0 : â„‚) 1 => x.val ^ i)
    --   (continuous_zpow_on_unit_circle i)) *
    --     (câ‚‚ j â€¢ ContinuousMap.mk (fun x : sphere (0 : â„‚) 1 => x.val ^ j)
    --       (continuous_zpow_on_unit_circle j)) = (câ‚ i * câ‚‚ j) â€¢ ContinuousMap.mk
    --         (fun x : sphere (0 : â„‚) 1 => x.val ^ (i + j)) (
    --           continuous_zpow_on_unit_circle (i + j)) := by
    --  -- By the properties of exponents, we can combine the terms on the left-hand side.
    --   have h_exp : âˆ€ x : sphere (0 : â„‚) 1, (x.val ^ i) * (x.val ^ j) = x.val ^ (i + j) := by
    --     intros x
    --     have hx : â€–(x : â„‚)â€– = 1 := by exact mem_sphere_zero_iff_norm.mp x.2
    --     rw [zpow_addâ‚€]
    --     exact norm_ne_zero_iff.mp (by simp [hx])
    --   ext x; simp [h_exp, mul_assoc, mul_left_comm, smul_smul]
    rw [mul_smul_comm]
    refine Submodule.smul_mem _ _ (Submodule.subset_span âŸ¨i + j, ?_âŸ©)
    ext x
    simp [ContinuousMap.mul_apply]
    rw [zpow_addâ‚€]
    unfold sphere at x
    obtain âŸ¨x, hxâŸ© := x
    dsimp at hx
    convert (zero_lt_one (Î± := â„)).trans_eq hx.symm using 1
    constructor
    Â· intro _ ; rw [hx] ; exact zero_lt_one
    Â· intro _ ; rw [â† dist_pos, hx] ; exact zero_lt_one
  | star =>
    rename_i hâ‚ hâ‚‚ hâ‚ƒ
    refine Submodule.span_induction ?_ ?_ ?_ ?_ hâ‚ƒ
    Â· simp [ContinuousMap.ext_iff]
      intro f n hn
      refine Submodule.subset_span âŸ¨-n, ?_âŸ©
      ext âŸ¨y, hyâŸ©
      have hy' : â€–yâ€– = 1 := by exact mem_sphere_zero_iff_norm.mp hy
      simp [hn y hy']
      rw [â† hn y hy', inv_def]
      simp [normSq_eq_norm_sq, hy']
    Â· simp [star_zero]
    Â· simp only [star_add, SetLike.mem_coe]
      exact fun x y hx hy hx' hy' => Submodule.add_mem _ hx' hy'
    Â· intro a x hx hsx
      rw [star_smul]
      exact Submodule.smul_mem _ _ hsx

--#count_heartbeats in
/-- If two finite measures agree on a dense subspace of continuous functions,
then they agree on all continuous functions. -/
lemma integral_eq_on_dense_set {X : Type*} [TopologicalSpace X] [CompactSpace X]
    [MeasurableSpace X] [BorelSpace X]
    (Î¼ Î½ : Measure X) [IsFiniteMeasure Î¼] [IsFiniteMeasure Î½]
    (S : Submodule â„‚ C(X, â„‚)) (hS : S.topologicalClosure = âŠ¤)
    (h : âˆ€ f âˆˆ S, âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î½) :
    âˆ€ f : C(X, â„‚), âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î½ := by
  /- The integrals are continuous maps on `C(X, â„‚)`. -/
  have h_cont : Continuous (fun f : C(X, â„‚) => âˆ« x, f x âˆ‚Î¼) âˆ§
    Continuous (fun f : C(X, â„‚) => âˆ« x, f x âˆ‚Î½) := by
    constructor <;> refine continuous_iff_continuousAt.2 fun f => ?_ <;>
    Â· refine tendsto_integral_filter_of_norm_le_const ?_ ?_ ?_
      Â· exact Filter.Eventually.of_forall fun g => g.continuous.aestronglyMeasurable
      Â· refine âŸ¨â€–fâ€– + 1, ?_âŸ©
        rw [Metric.eventually_nhds_iff]
        refine âŸ¨1, zero_lt_one, fun g hg => Filter.Eventually.of_forall fun x => ?_âŸ©
        have := ContinuousMap.norm_coe_le_norm g x
        refine le_trans this ?_
        calc  â€–gâ€– = â€–f + (g - f)â€– := by simp
          _ â‰¤ â€–fâ€– + â€–g - fâ€– := norm_add_le _ _
          _ â‰¤ â€–fâ€– + 1 :=  by rw [<- dist_eq_norm] ; exact add_le_add_left (le_of_lt hg) â€–fâ€–
      Â· exact Filter.Eventually.of_forall fun x => Continuous.tendsto (by continuity) _
  intro f
  /- Since `S` is dense in `C(X, â„‚)`, there exists a sequence `f_n` in `S`
  such that `f_n` converges to `f` uniformly. -/
  obtain âŸ¨f_n, hf_nâŸ© : âˆƒ f_n : â„• â†’ C(X, â„‚), (âˆ€ n, f_n n âˆˆ S) âˆ§
    Filter.Tendsto f_n Filter.atTop (ğ“ f) := by
    have h_dense : f âˆˆ S.topologicalClosure := by rw [hS] ; exact Submodule.mem_top
    exact mem_closure_iff_seq_limit.mp h_dense
  exact tendsto_nhds_unique (h_cont.1.continuousAt.tendsto.comp hf_n.2)
    (h_cont.2.continuousAt.tendsto.comp hf_n.2 |> Filter.Tendsto.congr (by
      intro x
      have hx : f_n x âˆˆ S := hf_n.1 x
      dsimp [(Â· âˆ˜ Â·)]
      symm
      exact h (f_n x) hx))

--#count_heartbeats in
/-- If two probability measures on the unit circle have the same moments, then they are equal. -/
lemma measure_eq_of_moments (Î¼â‚ Î¼â‚‚ : Measure (sphere (0 : â„‚) 1))
    [IsProbabilityMeasure Î¼â‚] [IsProbabilityMeasure Î¼â‚‚]
    (h : âˆ€ n : â„•, âˆ« x, x.val ^ n âˆ‚Î¼â‚ = âˆ« x, x.val ^ n âˆ‚Î¼â‚‚) : Î¼â‚ = Î¼â‚‚ := by
  -- The integrals of complex continuous functions with respect to `Î¼â‚` and `Î¼â‚‚` agree.
  have h_integrals : âˆ€ f : C((sphere (0 : â„‚) 1), â„‚), âˆ« x, f x âˆ‚Î¼â‚ = âˆ« x, f x âˆ‚Î¼â‚‚ := by
    apply_rules [integral_eq_on_dense_set]
    Â· exact span_moments_dense -- The span of the moments is dense in C(âˆ‚ğ”», â„‚).
    Â· intro f hf -- The integrals agree on the span of the moments.
      have h_integrals : âˆ€ n : â„¤, âˆ« x, x.val ^ n âˆ‚Î¼â‚ = âˆ« x, x.val ^ n âˆ‚Î¼â‚‚ :=
         fun n â†¦ moments_eq_integers âŸ¨Î¼â‚, inferInstanceâŸ© âŸ¨Î¼â‚‚, inferInstanceâŸ© h n
      rw [Finsupp.mem_span_range_iff_exists_finsupp] at hf
      obtain âŸ¨c, rflâŸ© := hf; simp_all [Finsupp.sum]
      rw [integral_finset_sum, integral_finset_sum]
      Â· simp only [integral_const_mul, h_integrals]
      Â· intro n hn; apply_rules [Integrable.const_mul, integrable_const]
        refine Integrable.mono' (g := fun _ => 1) ?_ ?_ ?_
        Â· norm_num
        Â· exact Continuous.aestronglyMeasurable (continuous_zpow_on_unit_circle n)
        Â· filter_upwards with x
          have hx : â€–(x : â„‚)â€– = 1 := by exact mem_sphere_zero_iff_norm.mp x.2
          simp [hx]
      Â· intro n hn; apply_rules [Integrable.const_mul, integrable_const]
        refine Integrable.mono' (g := fun _ => 1) ?_ ?_ ?_
        Â· norm_num
        Â· exact Continuous.aestronglyMeasurable (continuous_zpow_on_unit_circle n)
        Â· filter_upwards with x
          have hx : â€–(x : â„‚)â€– = 1 := by exact mem_sphere_zero_iff_norm.mp x.2
          simp [hx]
  -- The integrals of real continuous functions with respect to `Î¼â‚` and `Î¼â‚‚` agree.
  have h_eq : âˆ€ f : C((sphere (0 : â„‚) 1), â„), âˆ« x, f x âˆ‚Î¼â‚ = âˆ« x, f x âˆ‚Î¼â‚‚ := by
    intro f
    convert congr_arg re (h_integrals (ContinuousMap.mk (fun x =>
      f x : sphere (0 : â„‚) 1 â†’ â„‚)
      (by continuity))) using 1 <;> norm_num [Complex.ext_iff, integral_sub, integral_const_mul]
    Â· exact Eq.symm (by erw [integral_ofReal] ; norm_cast)
    Â· exact Eq.symm (by erw [integral_ofReal] ; norm_cast)
  exact ext_of_forall_integral_eq_of_IsFiniteMeasure fun f â†¦ h_eq f.toContinuousMap

--#count_heartbeats in -- TODO 45000
/-- If two power series are equal on the unit disc, then their coefficients are equal. -/
lemma coeffs_eq_of_series_eq (c1 c2 : â„• â†’ â„‚)
    (hc1 : âˆƒ M, âˆ€ n, â€–c1 nâ€– â‰¤ M) (hc2 : âˆƒ M, âˆ€ n, â€–c2 nâ€– â‰¤ M)
    (h : âˆ€ z : â„‚, â€–zâ€– < 1 â†’ âˆ‘' n, z ^ (n + 1) * c1 n = âˆ‘' n, z ^ (n + 1) * c2 n) : c1 = c2 := by
  ext n
  -- The series of differences is zero for all `z` in the unit disc.
  have h_eq : âˆ€ z : â„‚, â€–zâ€– < 1 â†’ âˆ‘' k, z ^ (k + 1) * (c1 k - c2 k) = 0 := by
    intro z hz
    convert sub_eq_zero.mpr (h z hz) using 1
    rw [â† Summable.tsum_sub]
    Â· congr
      ext n
      ring
    Â· /- Since `â€–zâ€– < 1`, the series Î£_{n=0}^âˆ |z|^{n+1} |c1 n| converges by
      the comparison test with the geometric series Î£_{n=0}^âˆ |z|^n. -/
      have h_summable : Summable (fun n => â€–zâ€– ^ (n + 1) * â€–c1 nâ€–) := by
        exact Summable.of_nonneg_of_le (fun n => mul_nonneg (pow_nonneg (norm_nonneg _) _)
          (norm_nonneg _)) (fun n => mul_le_mul_of_nonneg_left (hc1.choose_spec n)
            (pow_nonneg (norm_nonneg _) _))
              (Summable.mul_right _ <| summable_geometric_of_lt_one (norm_nonneg _)
                hz |> Summable.comp_injective <| Nat.succ_injective)
      exact Summable.of_norm <| by simpa using h_summable
    Â· have h_summable : Summable (fun n => â€–zâ€– ^ (n + 1) * â€–c2 nâ€–) := by
        exact Summable.of_nonneg_of_le (fun n => mul_nonneg (pow_nonneg (norm_nonneg _) _)
          (norm_nonneg _))
            (fun n => mul_le_mul_of_nonneg_left (hc2.choose_spec n)
              (pow_nonneg (norm_nonneg _) _))
                (Summable.mul_right _ <| summable_geometric_of_lt_one (norm_nonneg _)
                  hz |> Summable.comp_injective <| Nat.succ_injective)
      exact Summable.of_norm <| by simpa using h_summable
  -- We prove the equality of the coefficients by strong induction on `n`.
  induction n using Nat.strong_induction_on with
  | _ n ih =>
  -- Consider the limit of the difference series divided by z^(n + 1) as z approaches 0.
  have h_limit : Filter.Tendsto (fun z : â„‚ => (âˆ‘' k, z ^ (k + 1) * (c1 k - c2 k)) / z ^ (n + 1))
    (nhdsWithin 0 {0}á¶œ) (ğ“ ((c1 n - c2 n))) := by
    -- We rewrite the difference series by separating the `n+1`-th term.
    have h_series : âˆ€ z : â„‚, â€–zâ€– < 1 â†’ (âˆ‘' k, z ^ (k + 1) * (c1 k - c2 k)) =
      z^(n + 1) * (c1 n - c2 n) + âˆ‘' k, z^(k + n + 2) * (c1 (k + n + 1) - c2 (k + n + 1)) := by
      intro z hz
      -- We separate the first `n+1` terms of the series.
      rw [â† Summable.sum_add_tsum_nat_add]
      rotate_left
      Â· use n + 1
      Â· have h_summable : Summable (fun k => z ^ (k + 1) * (c1 k)) âˆ§
                          Summable (fun k => z ^ (k + 1) * (c2 k)) := by
          have h_summable : Summable (fun k => â€–zâ€– ^ (k + 1) * â€–c1 kâ€–) âˆ§
                            Summable (fun k => â€–zâ€– ^ (k + 1) * â€–c2 kâ€–) :=
                âŸ¨Summable.of_nonneg_of_le
                  (fun n => mul_nonneg (pow_nonneg (norm_nonneg _) _) (norm_nonneg _))
                  (fun n => mul_le_mul_of_nonneg_left (hc1.choose_spec n)
                                                      (pow_nonneg (norm_nonneg _) _))
                  (Summable.mul_right _ <| summable_geometric_of_lt_one (norm_nonneg _)
                                    hz |> Summable.comp_injective <| Nat.succ_injective),
                Summable.of_nonneg_of_le
                  (fun n => mul_nonneg (pow_nonneg (norm_nonneg _) _) (norm_nonneg _))
                  (fun n => mul_le_mul_of_nonneg_left (hc2.choose_spec n)
                                                      (pow_nonneg (norm_nonneg _) _))
                  (Summable.mul_right _ <| summable_geometric_of_lt_one (norm_nonneg _)
                                    hz |> Summable.comp_injective <| Nat.succ_injective)âŸ©
          exact âŸ¨Summable.of_norm <| by simpa using h_summable.1,
                  Summable.of_norm <| by simpa using h_summable.2âŸ©
        simpa only [mul_sub] using h_summable.1.sub h_summable.2
      Â· simp [add_assoc, Finset.sum_range_succ]
        exact Finset.sum_eq_zero fun i hi => by simp [ih i (Finset.mem_range.mp hi)]
    /- If we factor out `z^(n + 1)` from the series,
       then the limit of the series is the separated term, when z approaches 0. -/
    have h_factor : Filter.Tendsto
                      (fun z : â„‚ =>
                           (c1 n - c2 n) + âˆ‘' k, z ^ (k + 1) * (c1 (k + n + 1) - c2 (k + n + 1)))
                      (nhdsWithin 0 {0}á¶œ) (ğ“ ((c1 n - c2 n))) := by
      /- We shall use that the series is continuous on a neighborhood of `0`. -/
      have h_factor : ContinuousOn
                        (fun z : â„‚ =>
                            âˆ‘' k, z ^ (k + 1) * (c1 (k + n + 1) - c2 (k + n + 1)))
                        (closedBall 0 (1 / 2)) := by
        refine continuousOn_tsum
                  (u := fun k => (1 / 2) ^ (k + 1) * (hc1.choose + hc2.choose)) ?_ ?_ ?_
        Â· exact fun i => Continuous.continuousOn (by continuity)
        Â· exact Summable.mul_right _ (summable_geometric_two.mul_right _)
        Â· norm_num
          exact fun k z hz => mul_le_mul (pow_le_pow_leftâ‚€ (norm_nonneg _) hz _)
            (le_trans (norm_sub_le _ _) (add_le_add (hc1.choose_spec _) (hc2.choose_spec _)))
              (by positivity) (by positivity)
      exact tendsto_nhdsWithin_of_tendsto_nhds
        (by simpa using Filter.Tendsto.add
                          tendsto_const_nhds
                          (h_factor.continuousAt
                              (Metric.closedBall_mem_nhds _ <| by norm_num) |> fun h => h.tendsto))
    -- We use the limit of the series with the factored out `z^(n + 1)`.
    refine Filter.Tendsto.congr' ?_ h_factor
    filter_upwards [self_mem_nhdsWithin,
                    mem_nhdsWithin_of_mem_nhds (Metric.ball_mem_nhds _ zero_lt_one)] with z hz hz'
    -- We use the difference series with the separated `n+1`-th term.
    rw [h_series z <| by simpa using hz']
    rw [eq_div_iff <| pow_ne_zero _ hz]
    ring_nf
    rw [â† tsum_mul_left]
    congr
    ext k
    ring_nf
  /- Since the difference is zero for all `z` in a neighborhood of `0`, by h_eq,
  its limit must also be zero. -/
  have h_zero_limit : Filter.Tendsto (fun z : â„‚ =>
                                          (âˆ‘' k, z ^ (k + 1) * (c1 k - c2 k)) / z ^ (n + 1))
                                     (nhdsWithin 0 {0}á¶œ) (ğ“ 0) :=
    tendsto_const_nhds.congr'
      (by filter_upwards [self_mem_nhdsWithin,
                          mem_nhdsWithin_of_mem_nhds (Metric.ball_mem_nhds _ zero_lt_one)]
                         with z hz hz'; aesop) -- here we use h_eq
  exact eq_of_sub_eq_zero (tendsto_nhds_unique h_limit h_zero_limit)

--#count_heartbeats in
/-- We expand the Herglotzâ€“Riesz kernel into a power series at 0 by using that
 1/(1 - z/w) = Î£_{n=0}^âˆ (z/w)^n. -/
lemma kernel_expansion (z : â„‚) (hz : â€–zâ€– < 1) (w : â„‚) (hw : â€–wâ€– = 1) :
    (w + z) / (w - z) = 1 + 2 * âˆ‘' n : â„•, z ^ (n + 1) * star (w ^ (n + 1)) := by
  have h_expand : (1 : â„‚) + 2 * z / (w - z) = 1 + 2 * âˆ‘' n : â„•, (z / w) ^ (n + 1) := by
    have h_expand : âˆ‘' n : â„•, (z / w) ^ (n + 1) = z / w / (1 - z / w) := by
    -- We use the geometric series expansion.
      have h_geo_series : (âˆ‘' n : â„•, (z / w) ^ (n + 1)) =
        (z / w) * (âˆ‘' n : â„•, (z / w) ^ n) := by
        rw [â† tsum_mul_left] ; exact tsum_congr fun _ => by ring
      rw [h_geo_series, tsum_geometric_of_norm_lt_one]
      Â· rfl
      Â· rw [norm_div, hw, div_one]
        exact hz
    rw [h_expand]
    have w_ne : w â‰  0 := by
      intro hw0
      rw [hw0, norm_zero] at hw
      simp at hw  -- contradiction: 0 â‰  1
    field_simp [w_ne]
  convert h_expand using 1
  Â· rw [one_add_div]
    Â· ring
    Â· exact sub_ne_zero_of_ne <| by rintro rfl; rw [hw] at hz ; exact (not_lt_of_ge (le_refl 1) hz)
  Â· simp [div_pow]
    congr! 2
    rw [div_eq_mul_inv, inv_def]
    simp [normSq_eq_norm_sq,hw]

--#count_heartbeats in
/-- The kernel_expansion is used to rewrite the integral. -/
lemma integral_kernel_expansion
    (Î¼ : ProbabilityMeasure (sphere (0 : â„‚) 1)) (z : â„‚) (hz : â€–zâ€– < 1) :
    âˆ« x : sphere (0 : â„‚) 1, (x + z) / (x - z) âˆ‚Î¼ = 1 + 2 * âˆ‘' n : â„•,
      z ^ (n + 1) * âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (n + 1)) âˆ‚Î¼ := by
  -- We apply the integral to the kernel_expansion. -/
  have h_integral : âˆ« x : sphere (0 : â„‚) 1, (x + z) / (x - z) âˆ‚Î¼ =
     âˆ« x : sphere (0 : â„‚) 1, (1 + 2 * âˆ‘' n : â„•, z ^ (n + 1) * star ((x : â„‚) ^ (n + 1))) âˆ‚Î¼ := by
    apply integral_congr_ae (by filter_upwards with x; apply kernel_expansion z hz; simp)
  rw [h_integral, integral_add, integral_const_mul]
  all_goals norm_num
  Â· -- We interchange the integral and the sum.
    rw [integral_tsum]
    Â· exact tsum_congr fun _ => integral_const_mul _ _
    Â· fun_prop (disch := norm_num)
    Â· refine ne_of_lt (lt_of_le_of_lt (ENNReal.tsum_le_tsum
        (g := fun n => ENNReal.ofReal (â€–zâ€– ^ (n + 1))) fun n => ?_) ?_)
      Â· refine le_trans (lintegral_mono_ae (g := fun _ => ENNReal.ofReal (â€–zâ€– ^ (n + 1))) ?_) ?_
        Â· simp [ENorm.enorm]
          filter_upwards with a
          simp [show â€–(a : â„‚)â€–â‚Š = 1 from by ext; simp]
        Â· norm_num
      Â· rw [â† ENNReal.ofReal_tsum_of_nonneg] <;> norm_num
        exact Summable.comp_injective (summable_geometric_of_lt_one (norm_nonneg _) hz)
          (Nat.succ_injective)
  Â· /- The series Î£_{n=1}^âˆ z^n conj{x^n} is absolutely convergent,
    so the function is integrable. -/
    refine (MeasureTheory.Integrable.const_mul (c := (2 : â„‚)) ?_)
    refine Integrable.mono' (g := fun x => âˆ‘' n : â„•, â€–zâ€– ^ (n + 1) *
      â€–starRingEnd â„‚ (x : â„‚)â€– ^ (n + 1)) ?_ ?_ ?_
    Â· norm_num
    Â· refine Continuous.aestronglyMeasurable ?_
      refine continuous_tsum (u := fun n => â€–zâ€– ^ (n + 1)) ?_ ?_ ?_
      Â· fun_prop (disch := norm_num)
      Â· exact Summable.comp_injective (summable_geometric_of_lt_one (norm_nonneg _) hz)
          (Nat.succ_injective)
      Â· norm_num
    Â· refine Filter.Eventually.of_forall fun x => ?_;
      refine le_trans (norm_tsum_le_tsum_norm ?_) ?_;
      Â· simpa using summable_nat_add_iff 1 |>.2 <|
           summable_geometric_of_lt_one (norm_nonneg _) hz
      Â· refine le_of_eq ?_
        congr 1
        ext i
        rw [norm_mul, norm_pow, norm_pow]

--#count_heartbeats in
/-- If two probability measures on the unit circle yield the same Herglotzâ€“Riesz functions,
then they are equal. -/
theorem HerglotzRiesz_representation_uniqueness
    (Î¼â‚ Î¼â‚‚ : ProbabilityMeasure (sphere (0 : â„‚) 1))
    (h : âˆ€ z âˆˆ ball (0 : â„‚) 1, âˆ« x : sphere (0 : â„‚) 1, (x + z) / (x - z) âˆ‚Î¼â‚ =
      âˆ« x : sphere (0 : â„‚) 1, (x + z) / (x - z) âˆ‚Î¼â‚‚) :
    Î¼â‚ = Î¼â‚‚ := by
  -- We shall prove that the moments of `Î¼â‚` and `Î¼â‚‚` are equal.
  have h_coeffs : âˆ€ k : â„•,
        âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (k + 1)) âˆ‚Î¼â‚ =
        âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (k + 1)) âˆ‚Î¼â‚‚ := by
    /- By Lemma `integral_kernel_expansion`, we can expand the integrals into series. -/
    have h_integral_expansion : âˆ€ z : â„‚, â€–zâ€– < 1 â†’
      (âˆ‘' n : â„•, z ^ (n + 1) * âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (n + 1)) âˆ‚Î¼â‚) =
      (âˆ‘' n : â„•, z ^ (n + 1) * âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (n + 1)) âˆ‚Î¼â‚‚) := by
      intro z hz
      have h_integral_expansion1 : (âˆ« x : sphere (0 : â„‚) 1, ((x.val + z) / (x.val - z)) âˆ‚Î¼â‚) =
        1 + 2 * (âˆ‘' n : â„•, z ^ (n + 1) * âˆ« x : sphere (0 : â„‚) 1,
          star (x.val ^ (n + 1)) âˆ‚Î¼â‚) := integral_kernel_expansion Î¼â‚ z hz
      have h_integral_expansion2 : (âˆ« x : sphere (0 : â„‚) 1, ((x.val + z) / (x.val - z)) âˆ‚Î¼â‚‚) =
        1 + 2 * (âˆ‘' n : â„•, z ^ (n + 1) * âˆ« x : sphere (0 : â„‚) 1,
          star (x.val ^ (n + 1)) âˆ‚Î¼â‚‚) := integral_kernel_expansion Î¼â‚‚ z hz
      have hz' : z âˆˆ ball 0 1 := by
        rw [Metric.mem_ball, dist_eq]
        simp [hz]
      linear_combination' h z hz' / 2 - h_integral_expansion1 / 2 + h_integral_expansion2 / 2
    have h_bounds : âˆ€ n : â„•, â€–âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (n + 1)) âˆ‚Î¼â‚â€– â‰¤ 1 âˆ§
                             â€–âˆ« x : sphere (0 : â„‚) 1, star (x.val ^ (n + 1)) âˆ‚Î¼â‚‚â€– â‰¤ 1 := by
      intro n
      refine âŸ¨?_, ?_âŸ© <;> refine le_trans (norm_integral_le_integral_norm _) ?_
      all_goals simp
    -- We conclude the equality of the moments/coefficients by `coeffs_eq_of_series_eq`.
    apply_rules [coeffs_eq_of_series_eq]
    Â· exact âŸ¨1, fun n => h_bounds n |>.1âŸ©
    Â· exact âŸ¨1, fun n => h_bounds n |>.2âŸ©
  -- We conclude the equality of the measures by `measure_eq_of_moments`.
  have h : Î¼â‚.toMeasure = Î¼â‚‚.toMeasure := by
    apply_rules [measure_eq_of_moments]
    ext (_ | k) <;> simp at h_coeffs âŠ¢
    convert congr_arg Star.star (h_coeffs k) using 1
    Â· simp [â† integral_conj]
    Â· simp [â† integral_conj]
  exact Subtype.ext h
